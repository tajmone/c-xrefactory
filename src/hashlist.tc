/*

  .c template for hashed table of lists

  See hashtab.tc for usage.

  TOOD: unsure about exact difference between hashtab and hashlist...

*/

#define GLUE(a,b) a ## b
#define CONCAT(a,b) GLUE(a,b)

/* Here we create TAB_TYPE and FUN_PREFIX from TAB_NAME */
#define HASH_FUN_PREFIX HASH_TAB_NAME


void CONCAT(HASH_FUN_PREFIX,NoAllocInit)(HASH_TAB_TYPE *table, int size) {
    table->size = size;
    memset(table->tab, 0, sizeof(HASH_ELEM_TYPE *)*table->size);
}


void CONCAT(HASH_FUN_PREFIX,Init)(HASH_TAB_TYPE *table, int size) {
    XX_ALLOCC(table->tab, size, HASH_ELEM_TYPE *);
    CONCAT(HASH_FUN_PREFIX,NoAllocInit)(table, size);
}


bool CONCAT(HASH_FUN_PREFIX,IsMember)(
    HASH_TAB_TYPE *table,
    HASH_ELEM_TYPE *element,
    int *position,
    HASH_ELEM_TYPE **original) {
    unsigned posid;
    HASH_ELEM_TYPE *pp;

    posid = HASH_FUN(element);
    posid = posid % table->size;
    *position = posid;
    assert(table->tab != NULL);
    for (pp=table->tab[posid]; pp!=NULL; pp=pp->next) {
        if (HASH_ELEM_EQUAL(pp, element)) {
            *original = pp;
            return true;
        }
    }
    *original = NULL;
    return false;
}


int CONCAT(HASH_FUN_PREFIX,NextMember)(
    HASH_ELEM_TYPE *element,
    HASH_ELEM_TYPE **original
) {
    HASH_ELEM_TYPE *pp;
    assert(*original);
    for (pp= (*original)->next; pp!=NULL; pp=pp->next) {
        if (HASH_ELEM_EQUAL(pp, element)) {
            *original = pp;
            return(1);
        }
    }
    *original = NULL;
    return(0);
}


int CONCAT(HASH_FUN_PREFIX,MembEqual)(
    HASH_ELEM_TYPE *e1,
    HASH_ELEM_TYPE *e2
) {
    assert(e1 && e2);
    return(HASH_ELEM_EQUAL(e1, e2));
}


int CONCAT(HASH_FUN_PREFIX,Delete)(
    HASH_TAB_TYPE *t,
    HASH_ELEM_TYPE *element
) {
    unsigned posid;
    HASH_ELEM_TYPE **pp;
    posid = HASH_FUN(element);
    posid = posid % t->size;
    assert(t->tab!=NULL);
    for (pp= &(t->tab[posid]); *pp!=NULL; pp= &((*pp)->next)) {
        if (HASH_ELEM_EQUAL((*pp), element)) {
            *pp = (*pp)->next;
            return(1);
        }
    }
    return(0);
}


int CONCAT(HASH_FUN_PREFIX,DeleteExact)(
    HASH_TAB_TYPE *t,
    HASH_ELEM_TYPE *element
) {
    unsigned posid;
    HASH_ELEM_TYPE **pp;
    posid = HASH_FUN(element);
    posid = posid % t->size;
    assert(t->tab!=NULL);
    for (pp= &(t->tab[posid]); *pp!=NULL; pp= &((*pp)->next)) {
        if ((*pp) == element) {
            *pp = (*pp)->next;
            return(1);
        }
    }
    return(0);
}


int CONCAT(HASH_FUN_PREFIX,DeleteLast)(
    HASH_TAB_TYPE *t,
    HASH_ELEM_TYPE *element
) {
    unsigned posid;
    HASH_ELEM_TYPE **pp, **dd;
    posid = HASH_FUN(element);
    posid = posid % t->size;
    assert(t->tab!=NULL);
    dd = NULL;
    for (pp= &(t->tab[posid]); *pp!=NULL; pp= &((*pp)->next)) {
        if (HASH_ELEM_EQUAL((*pp), element)) {
            dd = pp;
        }
    }
    if (dd!=NULL) {
        *dd = (*dd)->next;
        return(1);
    }
    return(0);
}

void CONCAT(HASH_FUN_PREFIX,Set) (
    HASH_TAB_TYPE *t,
    HASH_ELEM_TYPE *element,
    int position
) {
    element->next = t->tab[position];
    t->tab[position] = element;
}

void CONCAT(HASH_FUN_PREFIX,SetLast) (
    HASH_TAB_TYPE *t,
    HASH_ELEM_TYPE *element,
    int position
) {
    HASH_ELEM_TYPE **pp;
    for (pp= &(t->tab[position]); *pp!=NULL; pp= &((*pp)->next))
        ;
    *pp = element;
    element->next = NULL;
}

void CONCAT(HASH_FUN_PREFIX,Add) (
    HASH_TAB_TYPE *t,
    HASH_ELEM_TYPE *element,
    int *position
) {
    HASH_ELEM_TYPE *origin;
    if (! CONCAT(HASH_FUN_PREFIX,IsMember)(t,element,position,&origin)) {
        CONCAT(HASH_FUN_PREFIX,Set) (t,element,*position);
    }
}


void CONCAT(HASH_FUN_PREFIX,Free)(HASH_TAB_TYPE *t) {
    XX_FREE(t->tab);
}


void CONCAT(HASH_FUN_PREFIX,Map)(
    HASH_TAB_TYPE *t,
    void (*fun)(HASH_ELEM_TYPE *)
) {
    int i;
    HASH_ELEM_TYPE *pp;
    for(i=0; i<t->size; i++) {
        for(pp=t->tab[i]; pp!=NULL; pp=pp->next) (*fun)(pp);
    }
}


void CONCAT(HASH_FUN_PREFIX,Map2)(
    HASH_TAB_TYPE *t,
    void (*fun)(HASH_ELEM_TYPE *, void *),
    void *a
) {
    int i;
    HASH_ELEM_TYPE *pp;
    for(i=0; i<t->size; i++) {
        for(pp=t->tab[i]; pp!=NULL; pp=pp->next) (*fun)(pp, a);
    }
}


void CONCAT(HASH_FUN_PREFIX,Map3)(
    HASH_TAB_TYPE *t,
    void (*fun)(int)
) {
    int i;
    for(i=0; i<t->size; i++) {
        if (t->tab[i] != NULL) (*fun)(i);
    }
}


void CONCAT(HASH_FUN_PREFIX,Map31)(
    HASH_TAB_TYPE *t,
    void (*fun)(int, void *, void *),
    void *arg1, void *arg2
) {
    int i;
    for(i=0; i<t->size; i++) {
        if (t->tab[i] != NULL) (*fun)(i,arg1,arg2);
    }
}

void CONCAT(HASH_FUN_PREFIX,Map32)(
    HASH_TAB_TYPE *t,
    void (*fun)(int, void *, void *, void *),
    void *arg1, void *arg2, void *arg3
) {
    int i;
    for(i=0; i<t->size; i++) {
        if (t->tab[i] != NULL) (*fun)(i,arg1,arg2,arg3);
    }
}


void CONCAT(HASH_FUN_PREFIX,Map4)(
    HASH_TAB_TYPE *t,
    void (*fun)(HASH_ELEM_TYPE *, int),
    int a
) {
    int i;
    HASH_ELEM_TYPE *pp;
    for(i=0; i<t->size; i++) {
        for(pp=t->tab[i]; pp!=NULL; pp=pp->next) (*fun)(pp, a);
    }
}


void CONCAT(HASH_FUN_PREFIX,Map5)(
    HASH_TAB_TYPE *t,
    void (*fun)(HASH_ELEM_TYPE *, void *),
    void *arg
) {
    int i;
    HASH_ELEM_TYPE *pp;
    for(i=0; i<t->size; i++) {
        for(pp=t->tab[i]; pp!=NULL; pp=pp->next) (*fun)(pp, arg);
    }
}


void CONCAT(HASH_FUN_PREFIX,Statistics)(
    HASH_TAB_TYPE *t,
    int *usedIndexes,
    int *elements,
    int *maxdepth
) {
    int i,ui,el,dp,mdp;
    HASH_ELEM_TYPE *pp;
    ui= el = dp = mdp = 0;
    for(i=0; i<t->size; i++) {
        if (t->tab[i]!=NULL) ui ++;
        dp = el;
        for(pp=t->tab[i]; pp!=NULL; pp=pp->next) {
            el++;
        }
        if (mdp < el-dp) {mdp = el-dp;}
    }
    *usedIndexes = ui;
    *elements = el;
    *maxdepth = mdp;
}


#undef GLUE
#undef CONCAT
#undef HASH_TAB_TYPE
#undef HASH_FUN_PREFIX

/* Local variables: */
/* Mode: c          */
/* End:             */

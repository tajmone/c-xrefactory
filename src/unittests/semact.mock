/* -*- c -*-*/
#include "../semact.h"
#include <cgreen/mocks.h>

void unpackPointers(Symbol *pp) {
  mock(pp);
}

int displayingErrorMessages(void) {
  return (int) mock();
}

void deleteSymDef(void *p) {
  mock(p);
}

void addSymbol(Symbol *pp, S_symbolTable *tab) {
  mock(pp, tab);
}

void recFindPush(Symbol *sym, S_recFindStr *rfs) {
  mock(sym, rfs);
}

S_recFindStr *iniFind(Symbol *s, S_recFindStr *rfs) {
  return (S_recFindStr *) mock(s, rfs);
}

bool javaOuterClassAccessible(Symbol *cl) {
  return (int) mock(cl);
}

int javaRecordAccessible(S_recFindStr *rfs, Symbol *applcl, Symbol *funcl, Symbol *rec, unsigned recAccessFlags) {
  return (int) mock(rfs, applcl, funcl, rec, recAccessFlags);
}

int javaRecordVisibleAndAccessible(S_recFindStr *rfs, Symbol *applCl, Symbol *funCl, Symbol *r) {
  return (int) mock(rfs, applCl, funCl, r);
}

int javaGetMinimalAccessibility(S_recFindStr *rfs, Symbol *r) {
  return (int) mock(rfs, r);
}

int findStrRecordSym(S_recFindStr *ss, char *recname, Symbol **res, int javaClassif, int accessCheck, int visibilityCheck) {
  return (int) mock(ss, recname, res, javaClassif, accessCheck, visibilityCheck);
}

Symbol *addNewSymbolDef(Symbol *p, unsigned storage, S_symbolTable *tab, int usage) {
  return (Symbol *) mock(p, storage, tab, usage);
}

Symbol *addNewDeclaration(Symbol *btype, Symbol *decl, S_idList *idl, unsigned storage, S_symbolTable *tab) {
  return (Symbol *) mock(btype, decl, idl, storage, tab);
}

int styyerror(char *s) {
  return (int) mock(s);
}

int styyErrorRecovery(void) {
  return (int) mock();
}

void setToNull(void *p) {
  mock(p);
}

Symbol *typeSpecifier1(unsigned t) {
  return (Symbol *) mock(t);
}

void declTypeSpecifier1(Symbol *d, unsigned t) {
  mock(d, t);
}

Symbol *typeSpecifier2(S_typeModifier *t) {
  return (Symbol *) mock(t);
}

void declTypeSpecifier2(Symbol *d, S_typeModifier *t) {
  mock(d, t);
}

void declTypeSpecifier21(S_typeModifier *t, Symbol *d) {
  mock(t, d);
}

S_typeModifier *appendComposedType(S_typeModifier **d, unsigned t) {
  return (S_typeModifier *) mock(d, t);
}

S_typeModifier *prependComposedType(S_typeModifier *d, unsigned t) {
  return (S_typeModifier *) mock(d, t);
}

void completeDeclarator(Symbol *t, Symbol *d) {
  mock(t, d);
}

void addFunctionParameterToSymTable(Symbol *function, Symbol *p, int i, S_symbolTable *tab) {
  mock(function, p, i, tab);
}

SymbolList *createDefinitionList(Symbol *symbol) {
  return (SymbolList *) mock(symbol);
}

Symbol *createSimpleDefinition(unsigned storage, unsigned t, S_id *id) {
  return (Symbol *) mock(storage, t, id);
}

int findStrRecord(Symbol *s, char *recname, Symbol **res, int javaClassif) {
  return (int) mock(s, recname, res, javaClassif);
}

S_reference *findStrRecordFromSymbol(Symbol *str, S_id *record, Symbol **res, int javaClassif, S_id *super) {
  return (S_reference *) mock(str, record, res, javaClassif, super);
}

S_reference *findStrRecordFromType(S_typeModifier *str, S_id *record, Symbol **res, int javaClassif) {
  return (S_reference *) mock(str, record, res, javaClassif);
}

int mergeArguments(Symbol *id, Symbol *ty) {
  return (int) mock(id, ty);
}

S_typeModifier *simpleStrUnionSpecifier(S_id *typeName, S_id *id, int usage) {
  return (S_typeModifier *) mock(typeName, id, usage);
}

S_typeModifier *crNewAnnonymeStrUnion(S_id *typeName) {
  return (S_typeModifier *) mock(typeName);
}

void specializeStrUnionDef(Symbol *sd, Symbol *rec) {
  mock(sd, rec);
}

S_typeModifier *simpleEnumSpecifier(S_id *id, int usage) {
  return (S_typeModifier *) mock(id, usage);
}

void setGlobalFileDepNames(char *iname, Symbol *pp, int memory) {
    char **pp_name = &pp->name;
    mock(iname, pp, pp_name, memory);
}

S_typeModifier *createNewAnonymousEnum(SymbolList *enums) {
  return (S_typeModifier *) mock(enums);
}

void appendPositionToList(S_positionList **list, S_position *pos) {
  mock(list, pos);
}

void setParamPositionForFunctionWithoutParams(S_position *lpar) {
  mock(lpar);
}

void setParamPositionForParameter0(S_position *lpar) {
  mock(lpar);
}

void setParamPositionForParameterBeyondRange(S_position *rpar) {
  mock(rpar);
}

Symbol *createEmptyField(void) {
  return (Symbol *) mock();
}

void handleDeclaratorParamPositions(Symbol *decl, S_position *lpar, S_positionList *commas, S_position *rpar, int hasParam) {
  mock(decl, lpar, commas, rpar, hasParam);
}

void handleInvocationParamPositions(S_reference *ref, S_position *lpar, S_positionList *commas, S_position *rpar, int hasParam) {
  mock(ref, lpar, commas, rpar, hasParam);
}

void javaHandleDeclaratorParamPositions(S_position *sym, S_position *lpar, S_positionList *commas, S_position *rpar) {
  mock(sym, lpar, commas, rpar);
}

void setLocalVariableLinkName(struct symbol *p) {
  mock(p);
}

void labelReference(S_id *id, int usage) {
  mock(id, usage);
}
